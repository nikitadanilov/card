#!/usr/bin/env python3
# -*- python -*-

"""A very simple "publishing" (I guess) tool, designed for a particular
workflow.

The input is a "deck", which is a set of "cards", each consisting of
"fragments". Fragments correspond to paragraphs and things like code and math
displays in the output. Cards are used to ogranise content into "series", they
can correspond to pages in the output, but not necessarily.

Decks, cards and fragments all have attributes.

"""

from __future__ import annotations
import sys
import pprint
import argparse
import os
import datetime
import collections
import html
import re
from typing import List, Dict, Optional, Tuple
from typeguard import typechecked # Must be installed.

@typechecked
class kv:
    """Base class for deck, card and fragment.

    kv knows has a parent kv, a dictionary of attributes and can pretty-print
    itself.

    """
    def __init__(self, parent : Optional[kv]):
        self.attrs  = {}
        self.parent = parent
    def set(self, key : str, value) -> None:
        """Sets the attribute. If attribute name starts with '+', then the value
        is added to the list.

        """
        assert len(key) > 0
        if key[0] == '+':
            key = key[1:]
            self.attrs[key] = self.attrs.get(key, []) + [value]
        else:
            self.attrs[key] = value
    def get(self, key, ttype : type = str, default = None):
        return ttype(self.attrs.get(key)) if self.has(key) else default
    def has(self, key : str) -> bool:
        return key in self.attrs
    def makeseq(self, base : str) -> str: # Need 'int'!
        return (base + '-' + '{:05}'.format(self.get('seq', int, None))).replace(' ', '-')
    def indent(self, n : int, lines) -> List[str]:
        return [n * ' ' + x.rstrip('\n') for x in lines]
    def dictstring(self, d) -> List[str]:
        return ['{} : {}'.format(key, d[key]) for key in d]
    def astring(self) -> List[str]:
        return self.dictstring(self.attrs)
    def tostring(self) -> List[str]:
        return self.astring()
    def __str__(self) -> str:
        return '\n'.join(self.tostring())
    
@typechecked
class frag(kv):
    def __init__(self, c : card):
        kv.__init__(self, c)
        self.lines = []
    def add(self, line : str):
        self.lines += [line]
    def content(self) -> str:
        return ''.join(self.lines).strip()
    def id(self) -> str:
        return self.makeseq(self.parent.id())
    def tostring(self) -> List[str]:
        return self.astring() + ['{'] + self.indent(8, self.lines) + ['}']

@typechecked
class para(frag):
    pass

@typechecked
class code(frag):
    def content(self) -> str: # Do not strip the code
        return ''.join(self.lines)

@typechecked
class math(frag):
    pass

frag_types = {
    'para' : para,
    'code' : code,
    'math' : math
}

@typechecked
class card(kv):
    def __init__(self, d : deck):
        kv.__init__(self, d)
        self.frags = []
    def frag_add(self, f : Optional[frag]) -> None:
        if f != None:
            assert(f.parent == self)
            f.set('seq', len(self.frags))
            self.frags += [f]
    def id(self) -> str:
        assert self.has('id') or self.has('file')
        return self.get('id') if self.has('id') else self.makeseq(self.get('file'))
    def fromfile(d : deck, file : str, fd : file, seq : int) -> card:
        c = card(d)
        stats = os.fstat(fd.fileno())
        c.set('file', file)
        c.set('seq', seq)
        c.set('mtime', datetime.datetime.fromtimestamp(stats.st_mtime))
        c.set('ctime', datetime.datetime.fromtimestamp(stats.st_ctime))
        return c
    def tostring(self) -> List[str]:
        return self.astring() + ['['] + self.indent(8, sum([f.tostring() for f in self.frags], [])) + [']']

@typechecked
class deck(kv):
    def __init__(self):
        kv.__init__(self, None)
        self.cards = []
        self.ids   = {}
        self.tags  = collections.defaultdict(list)
    def add(self, c : card) -> None:
        assert c.parent == self
        self.cards += [c]
    def configread(self, file : str) -> None:
        fd  = open(file, 'r')
        for line in fd:
            words = line.strip().split(maxsplit = 2)
            if words[0] == '/':
                self.set(words[1], words[2])
            else:
                assert False
        fd.close()
    def tagid(self, obj : kv) -> None:
        assert obj.id() not in self.ids   # Identifier must be unique.
        self.ids[obj.id()] = obj
        for t in obj.get('tags', list, []):
            self.tags[t] += [obj]
        for l in obj.get('=', list, []):  # Links.
            link(self, obj, l)
    def crossref(self) -> None:
        for c in self.cards:
            self.tagid(c)
            for f in c.frags:
                self.tagid(f)
    def build(self) -> None:
        engine = engines[self.get('engine', str, 'html')]()
        engine.run(self)
    def tostring(self) -> List[str]:
        return [''] + \
            ['<dock'] + \
            self.astring() + \
            ['--ids----'] + \
            self.indent(8, self.ids.keys()) + \
            ['--tags---'] + \
            self.indent(8, self.tags.keys()) + \
            ['--cards--'] + \
            self.indent(8, sum([c.tostring() + ['********'] for c in self.cards], [])) + \
            ['>']

@typechecked
class span:
    def __init__(self, obj : kv, regex : str):
        self.obj = obj
        self.regex = regex

link_src = 'link src'
link_tgt = 'link tgt'

@typechecked
class link:
    def __init__(self, d : deck, obj : kv, s : str):
        self.deck = d
        self.obj = obj
        self.s = s
        self.parse()
    def src(self):
        return self.src
    def tgt(self):
        return self.tgt
    def parse(self) -> None:
        parts = self.s.split('->', 1)
        self.src = self.locator_add(parts[0], '+' + link_src)
        self.tgt = self.locator_add(parts[1], '+' + link_tgt)
    def locator_add(self, loc : str, attr : str):
        host = None
        obj = self.obj
        loc = loc.strip()
        while len(loc) > 0:
            if loc[0] == '.':   # Current object
                loc = loc[1:]
            elif loc[0] == '"': # Span
                parts = loc[1:].split('"', 1)
                host = obj
                obj = span(obj, parts[0])
                loc = parts[1]
            elif loc[0] == '!': # Identifier.
                parts = loc[1:].split(' ', 1)
                obj = self.deck.ids[parts[0]]
                loc = parts[1] if len(parts) > 1 else ''
            else:
                assert False
            loc = loc.strip()
        (obj if host == None else host).set(attr, self)
        return obj
            
@typechecked
class eng:
    pass

html_file       = 'html.file'
html_anchor     = 'html.anchor'
html_content    = 'html.content'
html_style      = 'html.style'
html_style_file = 'html.style.file'

@typechecked
class html_eng(eng):
    def __init__(self):
        self.series = {}
        self.html_template = (
            '<!DOCTYPE html>\n'                               + 
            '<html>\n'                                        +
            ' <head>\n'                                       +
            '   <meta charset="UTF-8">\n'                     +
            '   <title>{title}</title>\n'                     +
            '   <link rel="stylesheet" href="{stylefile}">\n' +
            '   <style>{style}</style>\n'                     +
            ' </head>\n'                                      +
            ' <body>\n'                                       +
            '   <a name="{anchor}">{body}\n'                  +
            ' </body>\n'                                      +
            '</html>\n')
        self.anchor_template = '<a name="{anchor}">'
        self.frag_templates = {
            para : '<p style="{style}">{content}</p>',
            code : '<code style="{style}"><pre>{content}</pre></code>',
            math : '<math style="{style}">{content}</math>'
        }
        self.frag_default_template = '<p style="{style}">{content}</p>'
    def tag(self, tag : str, value : str) -> str:
        return '<{}>\{{{value}}}</{}>'.format(tag, value, tag)
    def run(self, d : deck) -> None:
        self.deck = d
        self.prep()
        self.frontmatter()
        for c in self.deck.cards:
            self.card_build(c)
        self.backmatter()
        self.index()
        for s in self.series:
            self.series_build(s)
        self.done()
    def prep(self) -> None:
        dir = self.deck.get('dir', str, 'html_out')
        os.mkdir(dir)
        os.chdir(dir)
        self.style_build()
    def done(self) -> None:
        os.chdir('..')
    def frontmatter(self) -> None:
        pass
    def backmatter(self) -> None:
        pass
    def card_build(self, c : card) -> None:
        file   = c.get(html_file, str, c.id() + '.html')
        anchor = html.escape(c.get(html_anchor, str, c.id()))
        title  = html.escape(c.get('name', str, c.get('label', str, 'Card {}'.format(c.id()))))
        frags  = '\n'.join([self.frag_render(f) for f in c.frags])
        self.out(file, self.html_template.format(**{ 'title'     : title,
                                                     'body'      : frags,
                                                     'stylefile' : self.style_file,
                                                     'style'     : self.style_text(c),
                                                     'anchor'    : anchor }))
        c.set(html_file,   file)
        c.set(html_anchor, anchor)
    def index(self) -> None:
        pass
    def series_build(self, s):
        pass
    def frag_render(self, f : frag) -> str:
        anchor = html.escape(f.get(html_anchor, str, f.id()))
        content = self.frag_links(f)
        arg = { 'content' : content,
                'anchor'  : anchor,
                'style'   : self.style_text(f) }
        template = self.frag_templates.get(type(f), self.frag_default_template)
        f.set(html_anchor, anchor)
        f.set(html_content, content)
        return (self.anchor_template + template).format(**arg)
    def out(self, f, content):
        with open(f, 'w') as fd:
            fd.write(content)
    def style_text(self, obj):
        return '\n'.join(obj.get(html_style, list, []))
    def style_build(self):
        self.style_file = self.deck.get(html_style_file, str, 'style.css')
        self.out(self.style_file, self.style_text(self.deck) + '\n')
    def href(self, src, tgt):
        h = '#' + tgt.get(http_anchor)
        file = tgt.get(http_file)
        if file != src.get(http_file):
            h = file + h
        return h
    def frag_links(self, f):
        parts = [(True, f.content())]
        extra = '\n'
        for l in f.get(link_src, list, []):
            if (type(l.src) == span):
                regex = re.compile(l.src.regex)
                pnew = []
                for ff in parts:
                    if not ff[0]:
                        pnew += [ff]
                    else:
                        s = ff[1]
                        for m in re.finditer(regex, s):
                            pnew += [(True,  s[0 : m.start()]),
                                     (False, '<a href="dasdjalsjd">'),
                                     (True,  s[m.start() : m.end()]),
                                     (False, '</a>'),
                                     (True,  s[m.end() : ])]
                        pnew += [(True, s)]
                parts = pnew
            else:
                assert l.src == f
                extra += '<p><a href="dsadaas">link</a></p>\n'
        return ''.join([html.escape(p[1]) if p[0] else p[1] for p in parts]) + extra

engines = {
    'html' : html_eng
}
    
@typechecked
def cardread(rolodex : deck, file : str) -> None:
    seq = 0
    fd  = open(file, 'r')
    c   = card.fromfile(rolodex, file, fd, seq)
    f   = None
    for rawline in fd:
        line = rawline.strip()
        words = line.split(maxsplit=2)
        if len(line) == 0:
            c.frag_add(f)
            f = None
        elif words[0] == '//':  # Card attribute
            c.set(words[1], words[2])
        elif words[0] == '/':   # Fragment attribute
            assert f != None
            f.set(words[1], words[2])
        elif words[0] == ';':   # Fragment type
            c.frag_add(f)
            f = frag_types[words[1]](c)
        elif words[0] == '\\':  # New card
            c.frag_add(f)
            rolodex.add(c);
            seq = seq + 1
            c = card.fromfile(rolodex, file, fd, seq)
            f = None
        else:
            if f == None:
                f = para(c)
            f.add(rawline)
    c.frag_add(f)
    rolodex.add(c);
    fd.close()

def main():
    parser = argparse.ArgumentParser(description='Card reader.')
    parser.add_argument('-c', '--config', type=str, default='card.conf', help='Config file.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    parser.add_argument('files', nargs=argparse.REMAINDER, help='Card files to be processed.')
    args = parser.parse_args()

    rolodex = deck()
    rolodex.configread(args.config)
    for file in args.files:
        cardread(rolodex, file)
    rolodex.crossref()
    rolodex.build()
    if args.verbose:
        print(rolodex)
        
if __name__ == '__main__':
    main()

#  Local variables:
#  python-indent-offset: 4
#  End:
