#!/usr/bin/env python3
# -*- python -*-

"""A very simple "publishing" (I guess) tool, designed for a particular
workflow.

The input is a "deck", which is a set of "cards", each consisting of
"fragments". Fragments correspond to paragraphs and things like code and math
displays in the output. Cards are used to ogranise content into "series", they
can correspond to pages in the output, but not necessarily.

Decks, cards and fragments all have attributes.

"""

from __future__ import annotations
import sys
import pprint
import argparse
import os
import datetime
import collections
import html
from typing import List, Dict, Optional, Tuple
from typeguard import typechecked # Must be installed.

@typechecked
class kv:
    """Base class for deck, card and fragment.

    kv knows has a parent kv, a dictionary of attributes and can pretty-print
    itself.

    """
    def __init__(self, parent : Optional[kv]):
        self.attrs  = {}
        self.parent = parent
    def set(self, key : str, value) -> None:
        """Sets the attribute. If attribute name starts with '+', then the value
        is added to the list.

        """
        assert len(key) > 0
        if key[0] == '+':
            key = key[1:]
            self.attrs[key] = self.attrs.get(key, []) + [value]
        else:
            self.attrs[key] = value
    def get(self, key, ttype : type = str, default = None):
        return ttype(self.attrs.get(key)) if self.has(key) else default
    def has(self, key : str) -> bool:
        return key in self.attrs
    def makeseq(self, base : str) -> str:
        return (base + '-' + '{:05}'.format(self.get('seq', int, None))).replace(' ', '-')
    def indent(self, n : int, lines : List[str]) -> List[str]:
        return [n * ' ' + x.rstrip('\n') for x in lines]
    def astring(self) -> List[str]:
        return ['{} : {}'.format(key, self.attrs[key]) for key in self.attrs]
    def tostring(self) -> List[str]:
        return self.astring()
    def __str__(self) -> str:
        return '\n'.join(self.tostring())
    
@typechecked
class frag(kv):
    def __init__(self, c : card):
        kv.__init__(self, c)
        self.lines = []
    def add(self, line : str):
        self.lines += [line]
    def content(self) -> str:
        return ''.join(self.lines).strip()
    def id(self) -> str:
        return self.makeseq(self.parent.id())
    def tostring(self) -> List[str]:
        return self.astring() + ['{'] + self.indent(8, self.lines) + ['}']

@typechecked
class para(frag):
    pass

@typechecked
class code(frag):
    def content(self) -> str: # Do not strip the code
        return ''.join(self.lines)

@typechecked
class math(frag):
    pass

frag_types = {
    'para' : para,
    'code' : code,
    'math' : math
}

@typechecked
class card(kv):
    def __init__(self, d : deck):
        kv.__init__(self, d)
        self.frags = []
    def frag_add(self, f : Optional[frag]) -> None:
        if f != None:
            assert(f.parent == self)
            f.set('seq', len(self.frags))
            self.frags += [f]
    def id(self) -> str:
        assert self.has('id') or self.has('file')
        return self.get('id') if self.has('id') else self.makeseq(self.get('file'))
    def fromfile(d : deck, file : str, fd : file, seq : int) -> card:
        c = card(d)
        stats = os.fstat(fd.fileno())
        c.set('file', file)
        c.set('seq', seq)
        c.set('mtime', datetime.datetime.fromtimestamp(stats.st_mtime))
        c.set('ctime', datetime.datetime.fromtimestamp(stats.st_ctime))
        return c
    def tostring(self) -> List[str]:
        return self.astring() + ['['] + self.indent(8, sum([f.tostring() for f in self.frags], [])) + [']']

@typechecked
class deck(kv):
    def __init__(self):
        kv.__init__(self, None)
        self.cards = []
    def add(self, c : card) -> None:
        assert c.parent == self
        self.cards += [c]
    def configread(self, file : str) -> None:
        fd  = open(file, 'r')
        for line in fd:
            words = line.strip().split(maxsplit = 2)
            if words[0] == '/':
                self.set(words[1], words[2])
            else:
                assert False
        fd.close()
    def tagid(self, obj : kv) -> None:
        assert obj.id() not in self.ids   # Identifier must be unique.
        self.ids[obj.id()] = obj
        for t in obj.get('tags', list, []):
            self.tags[t] += [obj]
        for l in obj.get('=', list, []):  # Links.
            link(self, obj, l)
    def crossref(self) -> None:
        self.ids  = collections.defaultdict(str)
        self.tags = collections.defaultdict(list)
        for c in self.cards:
            self.tagid(c)
            for f in c.frags:
                self.tagid(f)
    def build(self) -> None:
        engine = engines[self.get('engine', str, 'html')]()
        engine.run(self)
    def tostring(self) -> List[str]:
        return self.astring() + ['<'] + self.indent(8, sum([c.tostring() for c in self.cards], [])) + ['>']

@typechecked
class span:
    def __init__(self, obj : kv, regex : str):
        self.obj = obj
        self.regex = regex

@typechecked
class link:
    def __init__(self, d : deck, obj : kv, s : str):
        self.deck = d
        self.obj = obj
        self.s = s
        self.parse()
    def src(self):
        return self.src
    def tgt(self):
        return self.tgt
    def parse(self) -> None:
        parts = self.s.split('->', 1)
        self.src = self.locator_add(parts[0], '+link src')
        self.tgt = self.locator_add(parts[1], '+link dst')
    def locator_add(self, loc : str, attr : str):
        host = None
        obj = self.obj
        loc = loc.strip()
        while len(loc) > 0:
            if loc[0] == '.':   # Current object
                loc = loc[1:]
            elif loc[0] == '"': # Span
                parts = loc[1:].split('"', 1)
                host = obj
                obj = span(obj, parts[0])
                loc = parts[1]
            elif loc[0] == '!': # Identifier.
                parts = loc[1:].split(' ', 1)
                obj = self.deck.ids[parts[0]]
                loc = parts[1]
            loc = loc.strip()
        (obj if host == None else host).set(attr, self)
            
@typechecked
class eng:
    pass

@typechecked
class html_eng(eng):
    def __init__(self):
        self.series = {}
        self.html_template = ('<html>\n'                    +
                              ' <head>\n'                   +
                              '   <title>{title}</title>\n' +
                              ' </head>\n'                  +
                              ' <body>\n'                   +
                              '   <a name={id}>{body}\n'    +
                              ' </body>\n'                  +
                              '</html>\n')
        self.anchor_template = '<a name="{id}">'
        self.frag_template = '<p>{content}</p>'
        self.para_template = '<p>{content}</p>'
        self.code_template = '<code><pre>{content}</pre></code>'
        self.math_template = '<math>{content}</math>'
    def tag(self, tag : str, value : str) -> str:
        return '<{}>\{{{value}}}</{}>'.format(tag, value, tag)
    def run(self, d : deck) -> None:
        self.deck = d
        self.prep()
        self.frontmatter()
        for c in self.deck.cards:
            self.card_build(c)
        self.backmatter()
        self.index()
        for s in self.series:
            self.series_build(s)
        self.done()
    def prep(self) -> None:
        dir = self.deck.get('dir', str, 'html_out')
        os.mkdir(dir)
        os.chdir(dir)
    def done(self) -> None:
        os.chdir('..')
    def frontmatter(self) -> None:
        pass
    def backmatter(self) -> None:
        pass
    def card_build(self, c : card) -> None:
        html_file = c.id() + '.html'
        title     = html.escape(c.get('name', str, c.get('label', str, 'Card {}'.format(c.id()))))
        frags     = '\n'.join([self.frag_render(f) for f in c.frags])
        with open(html_file, 'w') as file:
            file.write(self.html_template.format(**{ 'title' : title,
                                                     'body'  : frags,
                                                     'id'    : html.escape(c.id())}))
    def index(self) -> None:
        pass
    def index(self) -> None:
        pass
    def series_build(self, s):
        pass
    def escape(self, d : dict[str, str]) -> dict[str, str]:
        return { key : html.escape(d[key]) for key in d }
    def frag_render(self, f : frag) -> str:
        arg = { 'content' : f.content(), 'id' : f.id() }
        if isinstance(f, para):
            template = self.para_template
        elif isinstance(f, code):
            template = self.code_template
        elif isinstance(f, math):
            template = self.math_template
        else:
            template = self.frag_template
        return (self.anchor_template + template).format(**self.escape(arg))
        
engines = {
    'html' : html_eng
}
    
@typechecked
def cardread(rolodex : deck, file : str) -> None:
    seq = 0
    fd  = open(file, 'r')
    c   = card.fromfile(rolodex, file, fd, seq)
    f   = None
    for rawline in fd:
        line = rawline.strip()
        words = line.split(maxsplit=2)
        if len(line) == 0:
            c.frag_add(f)
            f = None
        elif words[0] == '//':  # Card attribute
            c.set(words[1], words[2])
        elif words[0] == '/':   # Fragment attribute
            assert f != None
            f.set(words[1], words[2])
        elif words[0] == ';':   # Fragment type
            c.frag_add(f)
            f = frag_types[words[1]](c)
        elif words[0] == '\\':  # New card
            c.frag_add(f)
            rolodex.add(c);
            seq = seq + 1
            c = card.fromfile(rolodex, file, fd, seq)
            f = None
        else:
            if f == None:
                f = para(c)
            f.add(rawline)
    c.frag_add(f)
    rolodex.add(c);
    fd.close()

def main():
    parser = argparse.ArgumentParser(description='Card reader.')
    parser.add_argument('-c', '--config', type=str, default='card.conf', help='Config file.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    parser.add_argument('files', nargs=argparse.REMAINDER, help='Card files to be processed.')
    args = parser.parse_args()

    rolodex = deck()
    rolodex.configread(args.config)
    for file in args.files:
        cardread(rolodex, file)
    rolodex.crossref()
    rolodex.build()
    print(rolodex)
        
if __name__ == '__main__':
    main()

#  Local variables:
#  python-indent-offset: 4
#  End:
