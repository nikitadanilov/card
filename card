#!/usr/bin/env python3
# -*- python -*-

"""A very simple "publishing" (I guess) tool, designed for a particular
workflow.

The input is a "deck", which is a set of "cards", each consisting of
"fragments". Fragments correspond to paragraphs and things like code and math
displays in the output. Cards are used to ogranise content into "series", they
can correspond to pages in the output, but not necessarily.

Decks, cards and fragments all have attributes.

"""

from __future__ import annotations
import sys
import pprint
import argparse
import os
import datetime
import collections
import html
import re
import requests
import random
from typing import List, Dict, Optional, Tuple
from typeguard import typechecked # Must be installed.

@typechecked
class node:
    """Base class for deck, card and fragment.

    node has a parent node, a dictionary of attributes, a lists of formatting
    commands and can pretty-print itself.

    """
    def __init__(self, parent : Optional[node]):
        self.parent = parent
        self.attrs  = {}
        self.incmd  = []
        self.excmd  = []
    def set(self, key : str, value) -> None:
        """Sets the attribute. If attribute name starts with '+', then the value
        is added to the list.

        """
        assert len(key) > 0
        if key[0] == '+':
            self.add(key[1:], value)
        else:
            self.attrs[key] = value
            if (self.debug(4)):
                print('set:   "{}" to "{}"'.format(key, self.attrs[key]))
    def add(self, key : str, value) -> None:
        self.attrs[key] = self.attrs.get(key, []) + [value]
        if (self.debug(4)):
            print('added: "{}" to "{}"'.format(key, self.attrs[key]))
    def get(self, key, ttype : type = str, default = None):
        return ttype(self.attrs.get(key)) if self.has(key) else default
    def has(self, key : str) -> bool:
        return key in self.attrs
    def debug(self, level : int) -> bool:
        return self.get('DEBUG', int, 0) >= level
    def pair(self, incmd : cmd, excmd : cmd):
        incmd.node = self
        excmd.node = self
        self.incmd = [incmd] + self.incmd
        self.excmd = self.excmd + [excmd]
    def into(self, incmd : cmd, excmd : cmd):
        incmd.node = self
        excmd.node = self
        self.incmd = self.incmd + [incmd]
        self.excmd = [excmd] + self.excmd
    def cadd(self, incmd : cmd):
        incmd.node = self
        self.incmd += [incmd]
    def ancestry(self) -> List[node]:
        a = []
        cur = self
        while cur != None:
            a += [cur]
            cur = cur.parent
        return a
    def join(self, attr : str):
        return sum([x.get(attr, list, []) for x in self.ancestry()], [])
    def deck(self):
        return self.ancestry()[-1]
    def brief(self, nr : int) -> str:
        return (self.get('brief') if self.has('brief') else self.content())[0:nr]
    def makeseq(self, base : str) -> str: # Need 'int' on the next line!
        return (base + '-' + '{:05}'.format(self.get('seq', int, None))).replace(' ', '-')
    def indent(self, n : int, lines) -> List[str]:
        return [n * ' ' + x.rstrip('\n') for x in lines]
    def astring(self) -> List[str]:
        return dictstring(self.attrs)
    def tostring(self) -> List[str]:
        return self.astring() + \
            ['-incmds--'] + self.indent(8, [x.__str__() for x in self.incmd]) + \
            ['-excmds--'] + self.indent(8, [x.__str__() for x in self.excmd])
    def __str__(self) -> str:
        return '\n'.join(self.tostring())
    def __repr__(self) -> str:
        return self.__str__()
    
@typechecked
class frag(node):
    """A fragment is something like a paragraph, an image or a code display.

    Fragment's text is stored in self.lines. ':markers' attribute contains the
    list of markers associated with particular places in the text (given by
    offsets).
    """
    def __init__(self, c : card):
        node.__init__(self, c)
        self.lines = []
        self.set(':markers', collections.defaultdict(list))
        self.frag_indent = 0
    def line_add(self, line : str):
        self.lines += [line.rstrip('\n') + ' ']
    def content(self) -> str:
        return ''.join(self.lines).strip()
    def id(self) -> str:
        return (self.parent.id() + "-" + self.get('id')) if self.has('id') else self.makeseq(self.parent.id())
    def cut(self):
        """Split the processed content into text segments separated by marker commands."""
        text = self.get(':processed', str, self.content())
        last = 0
        markers = self.attrs.get(':markers', [])
        if (self.debug(2)):
            print('cut: markers-in ', recstring(markers))
        for idx in sorted(markers):
            if idx > 0:
                self.cadd(cmd(TEXT, text[last : idx]))
            for c in markers[idx]:
                self.cadd(c)
            last = idx
        self.cadd(cmd(TEXT, text[last:]))
    def program(self):
        return self.incmd + self.excmd
    def tostring(self) -> List[str]:
        return super().tostring() + ['{'] + self.indent(8, self.lines) + ['}']

@typechecked
class para(frag):
    pass

@typechecked
class code(frag):
    def content(self) -> str:
        return ''.join(self.lines).rstrip()
    def line_add(self, line : str):
        self.lines += [line] # Do not strip the code

@typechecked
class math(frag):
    def line_add(self, line : str):
        self.lines += [line] # Do not strip math

class img(frag):
    pass

frag_types = {
    'para' : para,
    'code' : code,
    'math' : math,
    'img'  : img
}

@typechecked
class card(node):
    def __init__(self, d : deck):
        node.__init__(self, d)
        self.frags = []
    def frag_add(self, f : Optional[frag]) -> None:
        if f != None:
            assert(f.parent == self)
            f.set('seq', len(self.frags))
            self.frags += [f]
    def id(self) -> str:
        assert self.has('id') or self.has('file')
        return self.get('id') if self.has('id') else self.makeseq(self.get('file'))
    def fromfile(d : deck, file : str, fd : file, seq : int) -> card:
        c = card(d)
        stats = os.fstat(fd.fileno())
        c.set('file', file)
        c.set('seq', seq)
        c.set('mtime', datetime.datetime.fromtimestamp(stats.st_mtime))
        c.set('ctime', datetime.datetime.fromtimestamp(stats.st_ctime))
        return c
    def content(self) -> str:
        return ' '.join([frag.content() for frag in self.frags])
    def program(self):
        return self.incmd + sum([f.program() for f in self.frags], []) + self.excmd
    def tostring(self) -> List[str]:
        return super().tostring() + ['['] + self.indent(8, sum([f.tostring() for f in self.frags], [])) + [']']

@typechecked
class deck(node):
    def __init__(self):
        node.__init__(self, None)
        self.cards  = []
        self.ids    = {}
        self.tags   = collections.defaultdict(list)
        self.series = collections.defaultdict(dict)
    def card_add(self, c : card) -> None:
        assert c.parent == self
        self.cards += [c]
    def configread(self, file : str) -> None:
        fd  = open(file, 'r')
        for line in fd:
            words = line.strip().split(maxsplit = 2)
            if words[0] == '/':
                self.set(words[1], words[2])
            else:
                assert False
        fd.close()
    def cardseries(self, obj : node, s : str) -> None:
        words = s.split()
        assert len(words) > 0
        trunk = words[0]
        zahl  = words[1] if len(words) > 1 else obj.id()
        assert zahl not in self.series[trunk]
        self.series[trunk][zahl] = obj
        obj.add(':#', (trunk, zahl))
    def id(self) -> str:
        return 'pleroma'
    def tagid(self, obj : node) -> None:
        assert obj.id() not in self.ids   # Identifier must be unique.
        self.ids[obj.id()] = obj
        for t in obj.get('tags', list, []):
            self.tags[t] += [obj]
        for s in obj.get('#', list, []):
            self.cardseries(obj, s)
    def makelinks(self, n : node):
        for l in n.join('='):           # Make links
            link(self, n, l)
        for x in n.get('*', list, []):  # Make notes
            note(self, n, x)
    def addstyles(self, n : node):
        # Only apply styles to paras. This should be done more generically.
        if not isinstance(n, frag) or isinstance(n, para):
            for s in stylenames:
                for regex in n.join(s):
                    n.add(':spans', stylespan(regex, s))
    def addlinks(self, n : node):
        for place in n.get(':links', list, []):
            assert place.parent != None
            n.cadd(cmd(place.parent.base(n) + L_HERE, place.parent))
    def addseries(self, c : card):
        for (trunk, zahl) in c.get(':#', list, []):
            sequence = list(self.series[trunk])
            sequence.sort()
            pos = sequence.index(zahl)
            c.cadd(cmd(SERIES, (trunk, self.series[trunk][sequence[pos - 1]] if pos > 0 else None,
                                       self.series[trunk][sequence[pos + 1]] if pos + 1 < len(sequence) else None)))
    def crossref(self) -> None:
        frag_cmds = {
            para : (PARA_BEGIN, PARA_END),
            math : (MATH_BEGIN, MATH_END),
            code : (CODE_BEGIN, CODE_END)
        }
        # Pass 0: build identifiers index, it is needed to resolve link names, etc. later.
        self.tagid(self)
        for c in self.cards:
            self.tagid(c)
            for f in c.frags:
                self.tagid(f)
        # Pass 1: build the links
        for c in self.cards:
            self.makelinks(c)
            for f in c.frags:
                self.makelinks(f)
        # Pass 2: build the command tree
        self.addlinks(self)
        self.addstyles(self)
        for c in self.cards:
            self.addlinks(c)
            self.addseries(c)
            self.addstyles(c)
            for f in c.frags:
                self.addlinks(f)
                self.addstyles(f)
                cmds = frag_cmds.get(type(f), (FRAG_BEGIN, FRAG_END))
                if f.has('>'):
                    indent = len(f.get('>', str, ''))
                    f.into(cmd(INDENT_BEGIN, indent), cmd(INDENT_END, indent))
                f.into(cmd(cmds[0]), cmd(cmds[1]))
                for s in f.get(':spans', list, []):
                    s.apply(f)
                f.cut()
            c.pair(cmd(CARD_BEGIN), cmd(CARD_END))
        self.pair(cmd(BEGIN), cmd(END))
    def program(self):
        """Build the program by traversing the node tree."""
        return self.incmd + sum([c.program() for c in self.cards], []) + self.excmd
    def build(self) -> None:
        # print('\n'.join([str(x) for x in self.program()]))
        engines[self.get('engine', str, 'html')]().run(self, self.program())
    def cardread(self : deck, file : str) -> None:
        seq = 0
        fd  = open(file, 'r')
        c   = card.fromfile(self, file, fd, seq)
        f   = None
        for rawline in fd:
            line = rawline.strip()
            words = line.split(maxsplit = 2)
            if len(line) == 0:
                c.frag_add(f)
                f = None
            elif words[0] == '///':          # Deck attribute
                self.set(words[1], words[2]) 
            elif words[0] == '//':           # Card attribute
                c.set(words[1], words[2])
            elif words[0] == '/':            # Fragment attribute
                assert f != None
                f.set(words[1], words[2])
            elif words[0] == ';':            # Fragment type
                c.frag_add(f)
                f = frag_types[words[1]](c)
            elif words[0] == '\\':           # New card
                c.frag_add(f)
                self.card_add(c);
                seq = seq + 1
                c = card.fromfile(self, file, fd, seq)
                f = None
            else:
                if f == None:
                    f = para(c)
                if rawline[0] == '|':        # Continuation
                    rawline = rawline[1:]
                else:
                    indent = 0
                    while rawline[0] == '>':
                        indent += 1
                        rawline = rawline[1:]
                    if indent != 0:
                        f.set('>', indent * '>')
                f.line_add(rawline)
        c.frag_add(f)
        self.card_add(c);
        fd.close()
    def tostring(self) -> List[str]:
        return [''] + \
            ['<dock'] + \
            super().tostring() + \
            ['--ids----'] + \
            self.indent(8, self.ids.keys()) + \
            ['--tags---'] + \
            self.indent(8, self.tags.keys()) + \
            ['--cards--'] + \
            self.indent(8, sum([c.tostring() + ['********'] for c in self.cards], [])) + \
            ['>']

class span:
    """A span is a pattern of contiguous extent of text decorated in some way.

    A span can be "applied" to a given a string, typically a fragment's content:
    find all extents in the string to which the span applies. For each match:

        - apply span transformation function,

        - add markers (which are typically commands) for the matched extent.

    """
    def __init__(self):
        pass
    def find(self, s : str):
        assert False # Define in sub-classes!
    def transform(self, s : str, m):
        assert False # Define in sub-classes!
        
    def apply(self, n : node) -> None:
        out     = n.get(':processed', str, n.content())
        markers = n.attrs[':markers']
        pos     = 0
        if (n.debug(2)):
            print('apply: markers-in', recstring(markers))
        while True:
            m = self.find(out, pos)
            if m == None:
                break
            (out, pos, deltas, inp, exp) = self.transform(out, m)
            if (n.debug(3)):
                print('    out', out, '\n    pos', pos, '\n    deltas', recstring(deltas),
                      '\n    inp', recstring(inp), '\n    exp', recstring(exp));
            for (p, delta) in deltas: # Adjust existing markers to the changed offsets.
                if delta == 0:
                    continue
                for idx in sorted(markers, reverse = delta > 0):
                    if idx > p:
                        markers[idx + delta] += markers[idx]
                        del markers[idx]
                if (n.debug(3)):
                    print('    Adjusted markers to ', p, delta)
                    print('             markers    ', recstring(markers))
            for (idx, cmd) in inp:
                markers[idx] = markers[idx] + [cmd]
            for (idx, cmd) in exp:
                markers[idx] = [cmd] + markers[idx]
        n.set(':markers', markers)
        n.set(':processed', out)
        if (n.debug(2)):
            print('apply: markers-ex', recstring(markers))

class respan(span):
    """Span based on a regular expression."""
    def __init__(self, pattern : str):
        self.re    = pattern
        self.regex = re.compile(pattern)
    def find(self, s : str, pos : int):
        return self.regex.search(s, pos)
    def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
        return (s, m.end(), [], [], [])
    def __str__(self) -> str:
        return 'respan: "' + self.re + '"'
    def __repr__(self) -> str:
        return self.__str__()
    
@typechecked
class place:
    """A place is the source or the target of a link.
    """
    pass

@typechecked
class url_place(place):
    def __init__(self, parent : Optional[link], url : str):
        self.url  = url
        self.node = None
        self.parent = parent
    def __str__(self) -> str:
        return 'url: ' + self.url

@typechecked
class node_place(place):
    def __init__(self, parent : Optional[link], n : node):
        self.node = n
        self.parent = parent
        self.node.add(':links', self)
    def __str__(self) -> str:
        return 'node: ' + self.node.id()

@typechecked
class span_place(place):
    class link_span(respan):
        def __init__(self, place : span_place, re : str):
            super().__init__(re)
            self.place = place
        def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
            # Adjust the other end, given the match.
            oldlink = self.place.parent
            if self.place.base == LSRC_BASE:
                other = oldlink.tgt
            else:
                other = oldlink.src
            if isinstance(other, url_place):
                # Create new link with replaced target
                newlink = link(oldlink.obj.deck(), oldlink.obj, ". -> .")
                copy = url_place(newlink, other.url.format(**m.groupdict()))
                if self.place.base == LSRC_BASE:
                    newlink.tgt = copy
                else:
                    newlink.src = copy
                oldlink = newlink
            return (s, m.end(), [],
                    [(m.start(), cmd(self.place.base + L_START, oldlink))],
                    [(m.end(),   cmd(self.place.base + L_END,   oldlink))])
    def __init__(self, parent, obj : node, pattern : str, base : int):
        self.node   = obj
        self.parent = parent
        self.span   = span_place.link_span(self, pattern)
        self.base   = base
        self.pattern = pattern
        self.node.add(':spans', self.span)
    def __str__(self) -> str:
        return 'span_place: "' + self.pattern + '"'
    def __repr__(self) -> str:
        return self.__str__()

class cmdspan(respan):
    """Span decorating the extent with particular commands."""
    def __init__(self, pattern : str, acts : Dict[str, (Optional[str], Optional[cmd], Optional[cmd])]):
        super().__init__(pattern)
        self.acts = acts
    def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
        # Sort the matched groups
        groups = sorted([(m.span(aname), aname) for aname in self.acts], key = lambda x: x[0][0])
        out  = ''
        last = 0
        inp  = []
        exp  = []
        deltas = []
        for ((start, end), aname) in groups:
            (replacement, incmd, excmd) = self.acts[aname]
            if start > 0:
                out += s[last : start]
            orig = m.group(aname)
            repl = replacement.format(orig)
            if replacement != None:
                out += repl
                deltas += [(len(out), len(repl) - len(orig))]
            else:
                out += orig
            if incmd != None:
                inp += [(len(out), incmd)]
            if excmd != None:
                exp += [(len(out), excmd)]
            last = end
        term = len(out)
        out += s[last:]
        return (out, term, deltas, inp, exp)

class stylespan(cmdspan):
    def __init__(self, pattern : str, style : str):
        styleop = stylenames[style]
        super().__init__(pattern, { 'open'  : ('', cmd(STYLE_BEGIN, styleop), None),
                                    'close' : ('', None, cmd(STYLE_END, styleop)) })

@typechecked
class link:
    """Hyperlink.

    A link connects two places: the source to the target. A place can be: a node
    (card or fragment), a span within a node (defined via regular expression, or
    line number, or...) or a URL.

    Link attribute ('=') grammar:

        LINK  ::= SRC '->' TGT
        SRC   ::= PLACE
        TGT   ::= PLACE
        PLACE ::= URL | NODE [SPAN]
        URL   ::= ...
        NODE  ::= '.' | '!' IDENTIFIER
        SPAN  ::= '"' REGEX '"'
    """
    def __init__(self, d : deck, obj : node, s : str):
        self.deck = d
        self.obj = obj
        self.s = s
        self.quoted = False
        self.parse()
    def parse(self) -> None:
        parts = self.s.split('->', 1)
        self.src = self.place(parts[0].strip(), LSRC_BASE)
        self.tgt = self.place(parts[1].strip(), LTGT_BASE)
    def place(self, s : str, base : int) -> place:
        assert len(s) > 0
        rest = s[1:].strip()
        if   s[0] == '.':
            obj = self.obj
        elif s[0] == '!':
            parts = rest.split(' ', 1)
            obj   = self.deck.ids[parts[0]]
            rest  = parts[1] if len(parts) > 1 else ''
        else:
            return url_place(self, s)
        rest = rest.strip()
        if rest != '':
            assert rest[ 0] == '"'
            assert rest[-1] == '"'
            parts = rest[1:].split('"', 1)
            return span_place(self, obj, rest[1:-1], base)
        else:
            return node_place(self, obj)
    def base(self, n : node) -> int:
        assert n == self.src.node or n == self.tgt.node
        return LSRC_BASE if n == self.src.node else LTGT_BASE
    def __str__(self) -> str:
        return self.src.__str__() + ' -> ' + self.tgt.__str__()
    def __repr__(self) -> str:
        return self.__str__()

@typechecked
class note:
    def __init__(self, d : deck, obj : node, s : str):
        s = s.lstrip()
        assert s[0] == '"'
        parts = s[1:].split('"', 1)
        self.text = parts[1]
        self.place = span_place(self, obj, parts[0], NOTE_BASE)
        self.src = self
        self.idx = None
        self.quoted = False
        obj.add(':notes', self)
        

@typechecked
class eng:
    pass

html_file       = 'html.file'
html_anchor     = 'html.anchor'
html_content    = 'html.content'
html_style      = 'html.style'
html_style_file = 'html.style.file'

@typechecked
class html_eng(eng):
    def __init__(self):
        self.html_card_begin = (
            '<!DOCTYPE html>\n'                               + 
            '<html>\n'                                        +
            ' <head>\n'                                       +
            '   <meta charset="UTF-8">\n'                     +
            '   <title>{title}</title>\n'                     +
            '   <link rel="stylesheet" href="{stylefile}">\n' +
            '   <style>{style}</style>\n'                     +
            '   {math}\n'                                     +
            ' </head>\n'                                      +
            ' <body>\n'                                       +
            '   <a name="{anchor}"></a>')
        self.html_card_end = (
            ' </body>\n'                                      +
            '</html>\n')
        self.html_anchor    = '<a name="{anchor}"></a>'
        self.indent_attr    = 'style="margin-left: {indent}em;"'
        self.html_frag_pair = {
            para : ('<p{attrs}>',         '</p>'),
            code : ('<pre><code{attrs}>', '</code></pre>'),
            math : ('$$',      '$$'),
            img  : ('<p{attrs}>',         '</p>'),
        }
        self.html_href_pair = ('<a href="{ref}">', '</a>')
        self.html_styles_pair = {
            S_EMPHASIS : ('<em>',   '</em>'),
            S_ITALIC   : ('<i>',    '</i>'),
            S_BOLD     : ('<b>',    '</b>'),
            S_UNDER    : ('<u>',    '</u>'),
            S_CODE     : ('<code class="inline">', '</code>'),
            S_MATH     : ('',    '') # Used only as a trigger to set card.hasmath.
        }
        self.html_img = '<img src="{url}" border="0" width=50%>'
        self.html_style_internal = (
            'span.annotation { border-bottom: 2px solid; }\n'                  +
            'span.annotation span.annotation { padding-bottom:4px; }\n'       +
            'span.annotation span.annotation span.annotation { padding-bottom:6px; }\n' +
            'span.annotation span.annotation span.annotation span.annotation { padding-bottom:8px; }\n' +
            'span.linktarget { border-bottom: 2px solid; }\n'                  +
            '\n' +
            '.column {\n' +
            '    max-width: 60%;\n' +
            '    margin-right: 20%;\n' +
            '    margin-left: 20%;\n' +
            '}\n' +
            '.margin-right {\n' +
            '    margin-right: -22%;\n' +
            '    margin-left: 2%;\n' +
            '    max-width: 20%;\n' +
            '    margin-top: 0;\n' +
            '    font-size: 80%;\n' +
            '    text-align: left;\n' +
            '    float: right;\n' +
            '}\n' +
            '.margin-left {\n' +
            '    margin-left: -22%;\n' +
            '    margin-right: 2%;\n' +
            '    max-width: 20%;\n' +
            '    margin-top: 0;\n' +
            '    text-align: right;\n' +
            '    float: left;\n' +
            '}\n' +
            'table.no-borders,\n' +
            'table.no-borders th,\n' +
            'table.no-borders td {\n' +
            '    border: none;\n' +
            '}\n' +
            'table.no-borders {\n' +
            '    border-collapse: collapse;\n' +
            '}\n' +
            'mjx-container[display="true"] {\n' +
            '    font-size: 1.2em !important;\n' +
            '}\n' +
            'mjx-container:not([display="true"]) {\n' +
            '    font-size: 1em !important;\n' +
            '}\n' +
            '\n')
        self.html_note_colours = [ 'orange', 'blue', 'red', 'green', 'purple', 'violet' ]
        self.html_note_span = 'span[data-uid="{uid}"] {{ border-color: {colour}; }}'
        self.html_math_script = """
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>"""
        self.commands = {
            CARD_BEGIN   : html_eng.card_begin,
            CARD_END     : html_eng.card_end,
            FRAG_BEGIN   : html_eng.frag_begin,
            FRAG_END     : html_eng.frag_end,
            PARA_BEGIN   : html_eng.para_begin,
            PARA_END     : html_eng.para_end,
            CODE_BEGIN   : html_eng.code_begin,
            CODE_END     : html_eng.code_end,
            MATH_BEGIN   : html_eng.math_begin,
            MATH_END     : html_eng.math_end,
            LSRC_HERE    : html_eng.forward,
            LSRC_START   : html_eng.forward,
            LSRC_END     : html_eng.forward,
            LTGT_HERE    : html_eng.forward,
            LTGT_START   : html_eng.ltgt_start,
            LTGT_END     : html_eng.forward,
            TEXT         : html_eng.forward,
            STYLE_BEGIN  : html_eng.style_begin,
            STYLE_END    : html_eng.forward,
            BEGIN        : html_eng.begin,
            END          : html_eng.end,
            SERIES       : html_eng.series,
            INDENT_BEGIN : html_eng.indent_begin,
            INDENT_END   : html_eng.indent_end,
            NOTE_HERE    : html_eng.forward,
            NOTE_START   : html_eng.note_start,
            NOTE_END     : html_eng.forward
        }
        self.render_commands = {
            LSRC_HERE    : html_eng.lsrc_here,
            LSRC_START   : html_eng.lsrc_start,
            LSRC_END     : html_eng.lsrc_end,
            LTGT_HERE    : html_eng.ltgt_here,
            LTGT_START   : html_eng.ltgt_start_render,
            LTGT_END     : html_eng.ltgt_end,
            TEXT         : html_eng.text,
            STYLE_BEGIN  : html_eng.style_begin_render,
            STYLE_END    : html_eng.style_end,
            NOTE_HERE    : html_eng.note_here,
            NOTE_START   : html_eng.note_start_render,
            NOTE_END     : html_eng.note_end
        }
    def run(self, d : deck, p : List[cmd]) -> None:
        self.deck = d
        for c in p:
            self.exec(c)
        self.render()
    def exec(self, c : cmd):
        self.commands[c.opc](self, c, c.node, c.obj)
    def file_begin(self, title : str, style : str, anchor : str, math : str):
        self.out(self.html_card_begin.format(**{ 'title'     : title,
                                                 'stylefile' : self.style_file,
                                                 'style'     : style,
                                                 'anchor'    : anchor,
                                                 'math'      : math }))
    def card_begin(self, c : cmd, n : card, o):
        assert o == None
        self.indent += 1
        self.frag_indent = 0
        n.ltgt_idx = 0
        n.series = []
        n.hasmath = False
    def card_end(self, c : cmd, n : card, o):
        assert o == None
        self.indent -= 1
    def frag_begin(self, c : cmd, n : frag, o):
        assert o == None
        self.indent += 1
        n.note_idx = random.randrange(len(self.html_note_colours))
        n.html_cmds = []
    def frag_end(self, c : cmd, n : frag, o):
        assert o == None
        self.indent -= 1
    def para_begin(self, c : cmd, n : para, o):
        self.frag_begin(c, n, o)
    def para_end(self, c : cmd, n : para, o):
        self.frag_end(c, n, o)
    def code_begin(self, c : cmd, n : code, o):
        self.frag_begin(c, n, o)
    def code_end(self, c : cmd, n : code, o):
        self.frag_end(c, n, o)
    def math_begin(self, c : cmd, n : math, o):
        n.parent.hasmath = True
        self.frag_begin(c, n, o)
    def math_end(self, c : cmd, n : math, o):
        self.frag_end(c, n, o)
    def forward(self, c : cmd, f : frag, o):
        f.html_cmds += [c]
    def lsrc_here(self, c : cmd, n : node, o : link):
        self.text(c, n, ' [')
        self.href_start(n, o.tgt)
        self.text(c, n, 'link')
        self.href_end()
        self.text(c, n, '] ')
    def lsrc_start(self, c : cmd, n : node, o : link):
        self.href_start(n, o.tgt)
    def lsrc_end(self, c : cmd, n : node, o : link):
        self.href_end()
    def ltgt_here(self, c : cmd, n : node, o : link):
        self.text(c, n, ' [')
        self.href_start(n, o.src)
        self.text(c, n, 'ref-by')
        self.href_end()
        self.text(c, n, '] ')
    def ltgt_start(self, c : cmd, n : node, o : link):
        o.idx = n.note_idx
        n.note_idx += 1
        n.add(':html-note-left', o)
        o.text = '[' + self.href_start_html(n, o.src) + \
            '<span style="color: {}">'.format(self.html_note_colours[o.idx % len(self.html_note_colours)]) + \
            str(n.parent.ltgt_idx) + \
            '</span>' + \
            self.href_end_html() + ']'
        n.parent.ltgt_idx += 1
        o.quoted = True
        o.br = False
        self.forward(c, n, o)
    def ltgt_start_render(self, c : cmd, n : node, o : link):
        self.out('<span class="linktarget" data-uid="{}">'.format(o.idx % len(self.html_note_colours)))
    def ltgt_end(self, c : cmd, n : node, o : link):
        self.out('</span>')
    def note_here(self, c : cmd, n : node, o : note):
        pass
    def note_start(self, c : cmd, n : node, o : note):
        o.idx = n.note_idx
        o.br = True
        n.note_idx += 1
        n.add(':html-note-right', o)
        self.forward(c, n, o)
    def note_start_render(self, c : cmd, n : node, o : note):
        self.out('<span class="annotation" data-uid="{}">'.format(o.idx % len(self.html_note_colours)))
    def note_end(self, c : cmd, n : node, o : note):
        self.out('</span>')
    def text(self, c : cmd, n : node, o : str):
        self.out(html.escape(o))
    def style_begin(self, c : cmd, n : node, style : int):
        if style == S_MATH:
            n.parent.hasmath = True
        self.forward(c, n, style)
    def style_begin_render(self, c : cmd, n : node, style : int):
        self.out(self.html_styles_pair[style][0])
    def style_end(self, c : cmd, n : node, style : int):
        self.out(self.html_styles_pair[style][1])
    def indent_begin(self, c : cmd, n : node, indent : int):
        self.frag_indent += indent
        n.frag_indent = self.frag_indent
    def indent_end(self, c : cmd, n : node, indent : int):
        self.frag_indent -= indent
    def begin(self, c : cmd, n : node, o):
        assert o == None
        self.prep()
        self.indent = 0
    def end(self, c : cmd, n : node, o):
        assert self.indent == 0
    def series(self, c : cmd, n : card, o : Tuple[str, Optional[card], Optional[card]]) -> None:
        n.series += [o]
    def prep(self): # Build all filenames and anchors.
        for c in self.deck.cards:
            file = c.get(html_file, str, c.id() + '.html')
            c.set(html_file, file)
            c.set(html_anchor, html.escape(c.get(html_anchor, str, c.id())))
            for f in c.frags:
                f.set(html_file, file)
                f.set(html_anchor, html.escape(f.get(html_anchor, str, f.id())))
    def series_file(self, trunk : str) -> str:
        return 'series_' + trunk + '.html'
    def tags_file(self, tag : str) -> str:
        return 'tags_' + tag + '.html'
    def series_index(self) -> None:
        for trunk in self.deck.series:
            self.fd = open(self.series_file(trunk), 'w')
            self.file_begin('Series ' + trunk, '', '', '')
            self.series_trunk(trunk)
            self.out(self.html_card_end)
            self.fd.close()
    def tags_index(self) -> None:
        for tag in self.deck.tags:
            self.fd = open(self.tags_file(tag), 'w')
            self.file_begin('Tag ' + tag, '', '', '')
            self.tag_list(tag)
            self.out(self.html_card_end)
            self.fd.close()
    def href_wrap(self, target : str, text : str) -> str:
        return self.html_href_pair[0].format(**{ 'ref' : target }) + \
            html.escape(text) + self.html_href_pair[1]
    def card_row(self, c : card) -> List[str]:
        title = self.href_wrap(c.get(html_file) + '#' + c.get(html_anchor),
                               c.get('card-title', str, None))
        brief = html.escape(c.brief(80) + ' ...')
        tags  = ' &nbsp; '.join([self.href_wrap(self.tags_file(t), t)
                                 for t in sorted(c.get('tags', list, []))])
        series = []
        trunks = {}
        for (trunk, z) in c.get(':#', list, []):
            trunks[trunk] = '+'
        for trunk in sorted(self.deck.series):
            series += ['<tt>' + trunks.get(trunk, '-') + '</tt>']
        return [title, brief, tags] + series
    def series_header(self):
        out = ''
        for t in sorted(self.deck.series):
            out += '<th>' + self.href_wrap(self.series_file(t), t) + '</th>'
        return out
    def series_trunk(self, trunk : str) -> None:
        sequence = list(self.deck.series[trunk])
        sequence.sort()
        self.out('<table class="no-borders">')
        self.out('<thead><tr><th></th><th>Name</th><th>Brief</th><th>Tags</th>' + \
                 self.series_header() + '</tr></thead>')
        for zahl in sequence:
            node = self.deck.series[trunk][zahl]
            self.out('<tr>')
            self.out('<td>')
            self.out(html.escape(zahl))
            self.out('</td>')
            for td in self.card_row(node):
                self.out('<td>')
                self.out(td)
                self.out('</td>')
            self.out('</tr>')
        self.out('</table>')
    def tag_list(self, tag : str) -> None:
        self.out('<table class="no-borders">')
        self.out('<thead><tr><th>Name</th><th>Brief</th><th>Tags</th>' + \
                 self.series_header() + '</tr></thead>')
        for node in self.deck.tags[tag]:
            self.out('<tr>')
            for td in self.card_row(node):
                self.out('<td>')
                self.out(td)
                self.out('</td>')
            self.out('</tr>')
        self.out('</table>')
    def href_start_html(self, fr : node, p : place):
        if isinstance(p, url_place):
            ref = p.url
        else:
            assert isinstance(p, span_place) or isinstance(p, node_place)
            ref = self.href(fr, p.node)
        return self.html_href_pair[0].format(**{ 'ref' : ref })
    def href_end_html(self):
        return self.html_href_pair[1]
    def href_start(self, fr : node, p : place):
        self.out(self.href_start_html(fr, p))
    def href_end(self):
        self.out(self.href_end_html())
    def formatif(self, notempty : str, empty : str, s : str):
        return empty if s == '' else notempty.format(s)
    def outnl(self, content : str):
        self.out('\n' + self.indent * 8 * ' ' + content)
    def out(self, content : str):
        self.fd.write(content)
    def style_text(self, obj):
        return '\n'.join(obj.get(html_style, list, []))
    def style_build(self):
        self.style_file = self.deck.get(html_style_file, str, 'style.css')
        with open(self.style_file, 'w') as fd:
            fd.write(self.html_style_internal + '\n')
            for i in range(0, len(self.html_note_colours)):
                fd.write(self.html_note_span.format(** { 'uid'    : i,
                                                         'colour' : self.html_note_colours[i] }) + '\n')
            fd.write(self.style_text(self.deck) + '\n')
    def href(self, fr : node, to : node):
        h = '#' + to.get(html_anchor)
        if fr.get(html_file) != to.get(html_file):
            h = to.get(html_file) + h
        return h
    def render(self):
        self.deck_render_begin(self.deck)
        for c in self.deck.cards:
            self.card_render_begin(self.deck, c)
            for f in c.frags:
                self.frag_render_begin(self.deck, c, f)
                self.frag_render_content(self.deck, c, f)
                self.frag_render_end(self.deck, c, f)
            self.card_render_end(self.deck, c)
        self.series_index()
        self.tags_index()
        self.deck_render_end(self.deck)
    def deck_render_begin(self, d : deck):
        dir = self.deck.get('dir', str, 'html_out')
        self.changedir = dir != '.'
        if self.changedir:
            os.makedirs(dir, exist_ok = True)
            os.chdir(dir)
        self.style_build()
    def deck_render_end(self, d : deck):
        if self.changedir:
            os.chdir('..')
    def card_render_begin(self, d : deck, c : card):
        self.fd = open(c.get(html_file, str, None), 'w')
        title = html.escape(c.get('name', str, c.get('label', str, 'Card {}'.format(c.id()))))
        c.set('card-title', title)
        self.file_begin(title, self.style_text(c), c.get(html_anchor, str, None),
                        self.html_math_script if c.hasmath else '')
        if c.hasmath:
            self.out('\n'.join(c.join('TeX')) + '\n')
        self.out('<div class="column">')
        self.out('<header>')
        self.out(title)
        self.out('</header>')
    def card_render_end(self, d : deck, c : card):
        self.out('<footer>')
        self.card_render_series(d, c)
        self.out('</footer>')
        self.out('</div>')
        self.outnl(self.html_card_end)
        self.fd.close()
    def card_render_series(self, d : deck, c : card):
        if len(c.series) > 0:
            for (trunk, prev, next) in c.series:
                if prev != None:
                    self.href_start(c, node_place(None, prev))
                self.render_text('<')
                if prev != None:
                    self.href_end()
                self.out('&nbsp;')
                self.href_start(c, url_place(None, self.series_file(trunk)))
                self.render_text(trunk)
                self.href_end()
                self.out('&nbsp;')
                if next != None:
                    self.href_start(c, node_place(None, next))
                self.render_text('>')
                if next != None:
                    self.href_end()
                self.out('&nbsp;&nbsp;&nbsp;')
    def frag_render_begin(self, d : deck, c : card, f : frag):
        for dir in ['left', 'right']:
            def fmt(s : string):
                return s.format(dir)
            if f.has(fmt(':html-note-{}')):
                self.out(fmt('<p class="margin-{}">'))
                for m in f.get(fmt(':html-note-{}'), list, []):
                    self.out('<span class="annotation" data-uid="{}">'.format(m.idx % len(self.html_note_colours)))
                    self.out(m.text) if m.quoted else self.render_text(m.text)
                    self.out('</span>&nbsp;')
                    self.out('<br>') if m.br else None
                self.out('</p>')
        attrs = self.formatif(' style="{}"', '', self.style_text(f))
        if f.frag_indent != 0:
            attrs += ' ' + self.indent_attr.format(**{ 'indent' : 3 * f.frag_indent })
        self.outnl((self.html_anchor + \
                    self.html_frag_pair[type(f)][0]).format(**{ 'anchor'  : f.get(html_anchor),
                                                                'attrs'   : attrs }))
        if isinstance(f, img):
            self.outnl(self.html_img.format(**{ 'url' : f.get('url') }))
    def frag_render_content(self, d : deck, c : card, f : frag):
        for c in f.html_cmds:
            self.render_commands[c.opc](self, c, c.node, c.obj)
    def frag_render_end(self, d : deck, c : card, f : frag):
        self.out(self.html_frag_pair[type(f)][1])
    def render_text(self, s : str):
        self.out(html.escape(s))
        
engines = {
    'html' : html_eng
}

L_HERE  = 0
L_START = 1
L_END   = 2

INVALID      =  0
CARD_BEGIN   =  1
CARD_END     =  2
FRAG_BEGIN   =  3
FRAG_END     =  4
PARA_BEGIN   =  5
PARA_END     =  6
CODE_BEGIN   =  7
CODE_END     =  8
MATH_BEGIN   =  9
MATH_END     = 10
LSRC_BASE    = 11
LSRC_HERE    = LSRC_BASE + L_HERE
LSRC_START   = LSRC_BASE + L_START
LSRC_END     = LSRC_BASE + L_END
LTGT_BASE    = 15
LTGT_HERE    = LTGT_BASE + L_HERE
LTGT_START   = LTGT_BASE + L_START
LTGT_END     = LTGT_BASE + L_END
TEXT         = 18
STYLE_BEGIN  = 19
STYLE_END    = 20
BEGIN        = 21
END          = 22
SERIES       = 23
INDENT_BEGIN = 24
INDENT_END   = 25
NOTE_BASE    = 26
NOTE_HERE    = NOTE_BASE + L_HERE
NOTE_START   = NOTE_BASE + L_START
NOTE_END     = NOTE_BASE + L_END

opnames = {
    INVALID      : 'INVALID',
    CARD_BEGIN   : 'CARD_BEGIN',
    CARD_END     : 'CARD_END',
    FRAG_BEGIN   : 'FRAG_BEGIN',
    FRAG_END     : 'FRAG_END',
    PARA_BEGIN   : 'PARA_BEGIN',
    PARA_END     : 'PARA_END',
    CODE_BEGIN   : 'CODE_BEGIN',
    CODE_END     : 'CODE_END',
    MATH_BEGIN   : 'MATH_BEGIN',
    MATH_END     : 'MATH_END',
    LSRC_HERE    : 'LSRC_HERE',
    LSRC_START   : 'LSRC_START',
    LSRC_END     : 'LSRC_END',
    LTGT_HERE    : 'LTGT_HERE',
    LTGT_START   : 'LTGT_START',
    LTGT_END     : 'LTGT_END',
    TEXT         : 'TEXT',
    STYLE_BEGIN  : 'STYLE_BEGIN',
    STYLE_END    : 'STYLE_END',
    BEGIN        : 'BEGIN',
    END          : 'END',
    SERIES       : 'SERIES',
    INDENT_BEGIN : 'INDENT_BEGIN',
    INDENT_END   : 'INDENT_END',
    NOTE_HERE    : 'NOTE_HERE',
    NOTE_START   : 'NOTE_START',
    NOTE_END     : 'NOTE_END'
}

S_EMPHASIS = 1
S_ITALIC   = 2
S_BOLD     = 3
S_CODE     = 4
S_UNDER    = 5
S_MATH     = 6

stylenames = {
    'em' : S_EMPHASIS,
    'it' : S_ITALIC,
    'bd' : S_BOLD,
    'un' : S_UNDER,
    'cd' : S_CODE,
    'ma' : S_MATH
}

@typechecked
class cmd:
    def __init__(self, opc : int, obj = None, n : Optional[node] = None):
        self.opc   = opc
        self.node  = n
        self.obj   = obj
        self.datum = None
    def __str__(self):
        return opnames[self.opc] + (' ' + self.obj if self.opc == TEXT else '')

def dictstring(d, eprint = lambda x: str(x)) -> List[str]:
    return ['{} : {}'.format(key, eprint(d[key])) for key in d]
def recstring(x) -> str:
    if isinstance(x, dict):
        return '{' + ', '.join(dictstring(x, recstring)) + '}'
    elif isinstance(x, list):
        return '[' + ', '.join([recstring(e) for e in x]) + ']'
    elif isinstance(x, tuple):
        return '(' + ', '.join([recstring(e) for e in x]) + ')'
    else:
        return x.__str__()

def main():
    parser = argparse.ArgumentParser(description='Card reader.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    parser.add_argument('files', nargs=argparse.REMAINDER, help='Card files to be processed.')
    args = parser.parse_args()

    rolodex = deck()
    for file in args.files:
        rolodex.cardread(file)
    rolodex.crossref()
    rolodex.build()
    if args.verbose:
        print(rolodex)
        
if __name__ == '__main__':
    main()

#  Local variables:
#  python-indent-offset: 4
#  End:
