#!/usr/bin/env python3
# -*- python -*-

"""A very simple "publishing" (I guess) tool, designed for a particular
workflow.

The input is a "deck", which is a set of "cards", each consisting of
"fragments". Fragments correspond to paragraphs and things like code and math
displays in the output. Cards are used to ogranise content into "series", they
can correspond to pages in the output, but not necessarily.

Decks, cards and fragments all have attributes.

"""

from __future__ import annotations
import sys
import pprint
import argparse
import os
import datetime
import collections
import html
import re
import requests
from typing import List, Dict, Optional, Tuple
from typeguard import typechecked # Must be installed.

@typechecked
class node:
    """Base class for deck, card and fragment.

    node has a parent node, a dictionary of attributes, a lists of formatting
    commands and can pretty-print itself.

    """
    def __init__(self, parent : Optional[node]):
        self.parent = parent
        self.attrs  = {}
        self.incmd  = []
        self.excmd  = []
    def set(self, key : str, value) -> None:
        """Sets the attribute. If attribute name starts with '+', then the value
        is added to the list.

        """
        assert len(key) > 0
        if key[0] == '+':
            self.add(key[1:], value)
        else:
            self.attrs[key] = value
    def add(self, key : str, value) -> None:
        self.attrs[key] = self.attrs.get(key, []) + [value]
    def get(self, key, ttype : type = str, default = None):
        return ttype(self.attrs.get(key)) if self.has(key) else default
    def has(self, key : str) -> bool:
        return key in self.attrs
    def pair(self, incmd : cmd, excmd : cmd):
        incmd.node = self
        excmd.node = self
        self.incmd = [incmd] + self.incmd
        self.excmd = self.excmd + [excmd]
    def into(self, incmd : cmd, excmd : cmd):
        incmd.node = self
        excmd.node = self
        self.incmd = self.incmd + [incmd]
        self.excmd = [excmd] + self.excmd
    def cadd(self, incmd : cmd):
        incmd.node = self
        self.incmd += [incmd]
    def makeseq(self, base : str) -> str: # Need 'int' on the next line!
        return (base + '-' + '{:05}'.format(self.get('seq', int, None))).replace(' ', '-')
    def indent(self, n : int, lines) -> List[str]:
        return [n * ' ' + x.rstrip('\n') for x in lines]
    def dictstring(self, d) -> List[str]:
        return ['{} : {}'.format(key, d[key]) for key in d]
    def astring(self) -> List[str]:
        return self.dictstring(self.attrs)
    def tostring(self) -> List[str]:
        return self.astring() + \
            ['-incmds--'] + self.indent(8, [x.__str__() for x in self.incmd]) + \
            ['-excmds--'] + self.indent(8, [x.__str__() for x in self.excmd])
    def __str__(self) -> str:
        return '\n'.join(self.tostring())
    def __repr__(self) -> str:
        return self.__str__()
    
@typechecked
class frag(node):
    """A fragment is something like a paragraph, an image or a code display.

    Fragment's text is stored in self.lines. ':markers' attribute contains the
    list of markers associated with particular places in the text (given by
    offsets).
    """
    def __init__(self, c : card):
        node.__init__(self, c)
        self.lines = []
        self.set(':markers', collections.defaultdict(list))
    def line_add(self, line : str):
        self.lines += [line]
    def content(self) -> str:
        return ''.join(self.lines).strip()
    def id(self) -> str:
        return self.makeseq(self.parent.id())
    def cut(self):
        """Split the processed content into text segments separated by marker commands."""
        text = self.get(':processed', str, self.content())
        last = 0
        markers = self.attrs.get(':markers', [])
        for idx in sorted(markers):
            if idx > 0:
                self.cadd(cmd(TEXT, text[last : idx]))
            for c in markers[idx]:
                self.cadd(c)
            last = idx
        self.cadd(cmd(TEXT, text[last:]))
    def program(self):
        return self.incmd + self.excmd
    def tostring(self) -> List[str]:
        return super().tostring() + ['{'] + self.indent(8, self.lines) + ['}']

@typechecked
class para(frag):
    pass

@typechecked
class code(frag):
    def content(self) -> str: # Do not strip the code
        return ''.join(self.lines).rstrip()

@typechecked
class math(frag):
    pass

frag_types = {
    'para' : para,
    'code' : code,
    'math' : math
}

@typechecked
class card(node):
    def __init__(self, d : deck):
        node.__init__(self, d)
        self.frags = []
    def frag_add(self, f : Optional[frag]) -> None:
        if f != None:
            assert(f.parent == self)
            f.set('seq', len(self.frags))
            self.frags += [f]
    def id(self) -> str:
        assert self.has('id') or self.has('file')
        return self.get('id') if self.has('id') else self.makeseq(self.get('file'))
    def fromfile(d : deck, file : str, fd : file, seq : int) -> card:
        c = card(d)
        stats = os.fstat(fd.fileno())
        c.set('file', file)
        c.set('seq', seq)
        c.set('mtime', datetime.datetime.fromtimestamp(stats.st_mtime))
        c.set('ctime', datetime.datetime.fromtimestamp(stats.st_ctime))
        return c
    def program(self):
        return self.incmd + sum([f.program() for f in self.frags], []) + self.excmd
    def tostring(self) -> List[str]:
        return super().tostring() + ['['] + self.indent(8, sum([f.tostring() for f in self.frags], [])) + [']']

@typechecked
class deck(node):
    def __init__(self):
        node.__init__(self, None)
        self.cards  = []
        self.ids    = {}
        self.tags   = collections.defaultdict(list)
        self.series = collections.defaultdict(dict)
    def card_add(self, c : card) -> None:
        assert c.parent == self
        self.cards += [c]
    def configread(self, file : str) -> None:
        fd  = open(file, 'r')
        for line in fd:
            words = line.strip().split(maxsplit = 2)
            if words[0] == '/':
                self.set(words[1], words[2])
            else:
                assert False
        fd.close()
    def cardseries(self, obj : node, s : str) -> None:
        words = s.split()
        assert len(words) > 0
        trunk = words[0]
        zahl  = words[1] if len(words) > 1 else obj.id()
        assert zahl not in self.series[trunk]
        self.series[trunk][zahl] = obj
        obj.add(':#', (trunk, zahl))
    def tagid(self, obj : node) -> None:
        assert obj.id() not in self.ids   # Identifier must be unique.
        self.ids[obj.id()] = obj
        for t in obj.get('tags', list, []):
            self.tags[t] += [obj]
        for s in obj.get('#', list, []):
            self.cardseries(obj, s)
    def makelinks(self, n : node):
        for l in n.get('=', list, []):
            link(self, n, l)
    def addstyles(self, n : node):
        for s in stylenames:
            for regex in n.get(s, list, []):
                n.add(':spans', stylespan(regex, s))
    def addlinks(self, n : node):
        for place in n.get(':links', list, []):
            assert place.parent != None
            n.cadd(cmd(place.parent.base(n) + L_HERE, place.parent))
    def addseries(self, c : card):
        for (trunk, zahl) in c.get(':#', list, []):
            sequence = list(self.series[trunk])
            sequence.sort()
            pos = sequence.index(zahl)
            c.cadd(cmd(SERIES, (trunk, self.series[trunk][sequence[pos - 1]] if pos > 0 else None,
                                       self.series[trunk][sequence[pos + 1]] if pos + 1 < len(sequence) else None)))
    def crossref(self) -> None:
        frag_cmds = {
            para : (PARA_BEGIN, PARA_END),
            math : (MATH_BEGIN, MATH_END),
            code : (CODE_BEGIN, CODE_END)
        }
        # Pass 0: build identifiers index, it is needed to resolve link names, etc. later.
        for c in self.cards:
            self.tagid(c)
            for f in c.frags:
                self.tagid(f)
        # Pass 1: build the links
        for c in self.cards:
            self.makelinks(c)
            for f in c.frags:
                self.makelinks(f)
        # Pass 2: build the command tree
        self.addstyles(self)
        for c in self.cards:
            self.addlinks(c)
            self.addseries(c)
            self.addstyles(c)
            for f in c.frags:
                self.addlinks(f)
                self.addstyles(f)
                cmds = frag_cmds.get(type(f), (FRAG_BEGIN, FRAG_END))
                f.into(cmd(cmds[0]), cmd(cmds[1]))
                for s in f.get(':spans', list, []) + c.get(':spans', list, []) + self.get(':spans', list, []):
                    s.apply(f)
                f.cut()
            c.pair(cmd(CARD_BEGIN), cmd(CARD_END))
        self.pair(cmd(BEGIN), cmd(END))
    def program(self):
        """Build the program by traversing the node tree."""
        return self.incmd + sum([c.program() for c in self.cards], []) + self.excmd
    def build(self) -> None:
        # print('\n'.join([str(x) for x in self.program()]))
        engines[self.get('engine', str, 'html')]().run(self, self.program())
    def cardread(self : deck, file : str) -> None:
        seq = 0
        fd  = open(file, 'r')
        c   = card.fromfile(self, file, fd, seq)
        f   = None
        for rawline in fd:
            line = rawline.strip()
            words = line.split(maxsplit = 2)
            if len(line) == 0:
                c.frag_add(f)
                f = None
            elif words[0] == '//':  # Card attribute
                c.set(words[1], words[2])
            elif words[0] == '/':   # Fragment attribute
                assert f != None
                f.set(words[1], words[2])
            elif words[0] == ';':   # Fragment type
                c.frag_add(f)
                f = frag_types[words[1]](c)
            elif words[0] == '\\':  # New card
                c.frag_add(f)
                self.card_add(c);
                seq = seq + 1
                c = card.fromfile(self, file, fd, seq)
                f = None
            else:
                if rawline[0] == '|': # Continuation
                    rawline = rawline[1:]
                if f == None:
                    f = para(c)
                f.line_add(rawline)
        c.frag_add(f)
        self.card_add(c);
        fd.close()
    def tostring(self) -> List[str]:
        return [''] + \
            ['<dock'] + \
            super().tostring() + \
            ['--ids----'] + \
            self.indent(8, self.ids.keys()) + \
            ['--tags---'] + \
            self.indent(8, self.tags.keys()) + \
            ['--cards--'] + \
            self.indent(8, sum([c.tostring() + ['********'] for c in self.cards], [])) + \
            ['>']

class span:
    """A span is a pattern of contiguous extent of text decorated in some way.

    A span can be "applied" to a given a string, typically a fragment's content:
    find all extents in the string to which the span applies. For each match:

        - apply span transformation function,

        - add markers (which are typically commands) for the matched extent.

    """
    def __init__(self):
        pass
    def find(self, s : str):
        assert False # Define in sub-classes!
    def transform(self, s : str, m):
        assert False # Define in sub-classes!
        
    def apply(self, n : node) -> None:
        out     = n.get(':processed', str, n.content())
        markers = n.attrs[':markers']
        pos     = 0
        while True:
            m = self.find(out, pos)
            if m == None:
                break
            (out, pos, deltas, inp, exp) = self.transform(out, m)
            for (p, delta) in deltas: # Adjust existing markers to the changed offsets.
                for idx in sorted(markers, reverse = delta > 0):
                    if idx > p:
                        markers[idx + delta] += markers[idx]
                        del markers[idx]
            for (idx, cmd) in inp:
                markers[idx] = markers[idx] + [cmd]
            for (idx, cmd) in exp:
                markers[idx] = [cmd] + markers[idx]
        n.set(':markers', markers)
        n.set(':processed', out)

class respan(span):
    """Span based on a regular expression."""
    def __init__(self, pattern : str):
        self.re    = pattern
        self.regex = re.compile(pattern)
    def find(self, s : str, pos : int):
        return self.regex.search(s, pos)
    def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
        return (s, m.end(), [], [], [])
    def __str__(self) -> str:
        return 'respan: "' + self.re + '"'
    def __repr__(self) -> str:
        return self.__str__()
    
@typechecked
class place:
    """A place is the source or the target of a link.
    """
    pass

@typechecked
class url_place(place):
    def __init__(self, parent : link, url : str):
        self.url  = url
        self.node = None
        self.parent = parent
    def __str__(self) -> str:
        return 'url: ' + self.url

@typechecked
class node_place(place):
    def __init__(self, parent : Optional[link], n : node):
        self.node = n
        self.parent = parent
        self.node.add(':links', self)
    def __str__(self) -> str:
        return 'node: ' + self.node.id()

@typechecked
class span_place(place):
    class link_span(respan):
        def __init__(self, place : span_place, re : str):
            super().__init__(re)
            self.place = place
        def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
            return (s, m.end(), [],
                    [(m.start(), cmd(self.place.base + L_START, self.place.parent))],
                    [(m.end(),   cmd(self.place.base + L_END,   self.place.parent))])
    def __init__(self, parent : link, obj : node, pattern : str, base : int):
        self.node   = obj
        self.parent = parent
        self.span   = span_place.link_span(self, pattern)
        self.base   = base
        if isinstance(self.node, card):
            assert self.parent != None
            self.node.add(':links', self)
        elif isinstance(self.node, frag):
            self.node.add(':spans', self.span)
    def __str__(self) -> str:
        return 'span_place: "' + self.pattern + '"'
    def __repr__(self) -> str:
        return self.__str__()

class cmdspan(respan):
    """Span decorating the extent with particular commands."""
    def __init__(self, pattern : str, acts : Dict[str, (Optional[str], Optional[cmd], Optional[cmd])]):
        super().__init__(pattern)
        self.acts = acts
    def transform(self, s : str, m) -> Tuple[str, int, List[Tuple[int, int]], List[Tuple(int, cmd)], List[Tuple(int, cmd)]]:
        # Sort the matched groups
        groups = sorted([(m.span(aname), aname) for aname in self.acts], key = lambda x: x[0][0])
        out  = ''
        last = 0
        inp  = []
        exp  = []
        deltas = []
        for ((start, end), aname) in groups:
            (replacement, incmd, excmd) = self.acts[aname]
            if start > 0:
                out += s[last : start]
            if replacement != None:
                out += replacement
                deltas += [(len(out), len(replacement) - len(m.group(aname)))]
            else:
                out += m.group(aname)
            if incmd != None:
                inp += [(len(out), incmd)]
            if excmd != None:
                exp += [(len(out), excmd)]
            last = end
        term = len(out)
        out += s[last:]
        return (out, term, deltas, inp, exp)

class stylespan(cmdspan):
    def __init__(self, pattern : str, style : str):
        styleop = stylenames[style]
        super().__init__(pattern, { 'open'  : ('', cmd(STYLE_BEGIN, styleop), None),
                                    'close' : ('', None, cmd(STYLE_END, styleop)) })

@typechecked
class link:
    """Hyperlink.

    A link connects two places: the source to the target. A place can be: a node
    (card or fragment), a span within a node (defined via regular expression, or
    line number, or...) or a URL.

    Link attribute ('=') grammar:

        LINK  ::= SRC '->' TGT
        SRC   ::= PLACE
        TGT   ::= PLACE
        PLACE ::= URL | NODE [SPAN]
        URL   ::= ...
        NODE  ::= '.' | '!' IDENTIFIER
        SPAN  ::= '"' REGEX '"'
    """
    def __init__(self, d : deck, obj : node, s : str):
        self.deck = d
        self.obj = obj
        self.s = s
        self.parse()
    def parse(self) -> None:
        parts = self.s.split('->', 1)
        self.src = self.place(parts[0].strip(), LSRC_BASE)
        self.tgt = self.place(parts[1].strip(), LTGT_BASE)
    def place(self, s : str, base : int) -> place:
        assert len(s) > 0
        rest = s[1:].strip()
        if   s[0] == '.':
            obj = self.obj
        elif s[0] == '!':
            parts = rest.split(' ', 1)
            obj   = self.deck.ids[parts[0]]
            rest  = parts[1] if len(parts) > 1 else ''
        else:
            return url_place(self, s)
        rest = rest.strip()
        if rest != '':
            assert rest[ 0] == '"'
            assert rest[-1] == '"'
            parts = rest[1:].split('"', 1)
            return span_place(self, obj, rest[1:-1], base)
        else:
            return node_place(self, obj)
    def base(self, n : node) -> int:
        assert n == self.src.node or n == self.tgt.node
        return LSRC_BASE if n == self.src.node else LTGT_BASE
    def __str__(self) -> str:
        return self.src.__str__() + ' -> ' + self.tgt.__str__()
    def __repr__(self) -> str:
        return self.__str__()
    
@typechecked
class eng:
    pass

html_file       = 'html.file'
html_anchor     = 'html.anchor'
html_content    = 'html.content'
html_style      = 'html.style'
html_style_file = 'html.style.file'

@typechecked
class html_eng(eng):
    def __init__(self):
        self.series = {}
        self.html_card_begin = (
            '<!DOCTYPE html>\n'                               + 
            '<html>\n'                                        +
            ' <head>\n'                                       +
            '   <meta charset="UTF-8">\n'                     +
            '   <title>{title}</title>\n'                     +
            '   <link rel="stylesheet" href="{stylefile}">\n' +
            '   <style>{style}</style>\n'                     +
            ' </head>\n'                                      +
            ' <body>\n'                                       +
            '   <a name="{anchor}"></a>');
        self.html_card_end = (
            ' </body>\n'                                      +
            '</html>\n')
        self.html_anchor     = '<a name="{anchor}"></a>'
        self.html_frag_pair = {
            para : ('<p{attrs}>',         '</p>'),
            code : ('<pre><code{attrs}>', '</code></pre>'),
            math : ('<math{attrs}>',      '</math>')
        }
        self.html_href_pair = ('<a href="{ref}">', '</a>')
        self.html_styles_pair = {
            S_EMPHASIS : ('<em>',   '</em>'),
            S_ITALIC   : ('<i>',    '</i>'),
            S_BOLD     : ('<b>',    '</b>'),
            S_CODE     : ('<code class="inline">', '</code>')
        }
        self.commands = {
            CARD_BEGIN  : html_eng.card_begin,
            CARD_END    : html_eng.card_end,
            FRAG_BEGIN  : html_eng.frag_begin,
            FRAG_END    : html_eng.frag_end,
            PARA_BEGIN  : html_eng.para_begin,
            PARA_END    : html_eng.para_end,
            CODE_BEGIN  : html_eng.code_begin,
            CODE_END    : html_eng.code_end,
            MATH_BEGIN  : html_eng.math_begin,
            MATH_END    : html_eng.math_end,
            LSRC_HERE   : html_eng.lsrc_here,
            LSRC_START  : html_eng.lsrc_start,
            LSRC_END    : html_eng.lsrc_end,
            LTGT_HERE   : html_eng.ltgt_here,
            LTGT_START  : html_eng.ltgt_start,
            LTGT_END    : html_eng.ltgt_end,
            TEXT        : html_eng.text,
            STYLE_BEGIN : html_eng.style_begin,
            STYLE_END   : html_eng.style_end,
            BEGIN       : html_eng.begin,
            END         : html_eng.end,
            SERIES      : html_eng.series
        }
    def run(self, d : deck, p : List[cmd]) -> None:
        self.deck = d
        for c in p:
            self.exec(c)
    def exec(self, c : cmd):
        self.commands[c.opc](self, c, c.node, c.obj)
    def card_begin(self, c : cmd, n : card, o):
        assert o == None
        self.indent += 1
        self.fd = open(n.get(html_file, str, None), 'w')
        title = html.escape(n.get('name', str, n.get('label', str, 'Card {}'.format(n.id()))))
        self.out(self.html_card_begin.format(**{ 'title'     : title,
                                                 'stylefile' : self.style_file,
                                                 'style'     : self.style_text(n),
                                                 'anchor'    : n.get(html_anchor, str, None) }))
    def card_end(self, c : cmd, n : card, o):
        assert o == None
        for c in n.get(':html-delay', list, []):
            self.exec(c)
        self.outnl(self.html_card_end)
        self.fd.close()
        self.indent -= 1
    def frag_begin(self, c : cmd, n : frag, o):
        assert o == None
        anchor = html.escape(n.get(html_anchor, str, n.id()))
        n.set(html_anchor, anchor)
        self.indent += 1
        attrs = self.formatif(' style="{}"', '', self.style_text(n))
        self.outnl((self.html_anchor + \
                    self.html_frag_pair[type(n)][0]).format(**{ 'anchor'  : anchor,
                                                                'attrs'   : attrs }))
    def frag_end(self, c : cmd, n : frag, o):
        assert o == None
        self.out(self.html_frag_pair[type(n)][1])
        self.indent -= 1
    def para_begin(self, c : cmd, n : para, o):
        self.frag_begin(c, n, o)
    def para_end(self, c : cmd, n : para, o):
        self.frag_end(c, n, o)
    def code_begin(self, c : cmd, n : code, o):
        self.frag_begin(c, n, o)
    def code_end(self, c : cmd, n : code, o):
        self.frag_end(c, n, o)
    def math_begin(self, c : cmd, n : math, o):
        self.frag_begin(c, n, o)
    def math_end(self, c : cmd, n : math, o):
        self.frag_end(c, n, o)
    def lsrc_here(self, c : cmd, n : node, o : link):
        self.text(c, n, ' [')
        self.href_start(n, o.tgt)
        self.text(c, n, 'link')
        self.href_end()
        self.text(c, n, '] ')
    def lsrc_start(self, c : cmd, n : node, o : link):
        self.href_start(n, o.tgt)
    def lsrc_end(self, c : cmd, n : node, o : link):
        self.href_end()
    def ltgt_here(self, c : cmd, n : node, o : link):
        self.text(c, n, ' [')
        self.href_start(n, o.src)
        self.text(c, n, 'ref-by')
        self.href_end()
        self.text(c, n, '] ')
    def ltgt_start(self, c : cmd, n : node, o : link):
        pass
    def ltgt_end(self, c : cmd, n : node, o : link):
        pass
    def text(self, c : cmd, n : node, o : str):
        self.out(html.escape(o))
    def style_begin(self, c : cmd, n : node, style : int):
        self.out(self.html_styles_pair[style][0])
    def style_end(self, c : cmd, n : node, style : int):
        self.out(self.html_styles_pair[style][1])
    def begin(self, c : cmd, n : node, o):
        assert o == None
        dir = self.deck.get('dir', str, 'html_out')
        os.mkdir(dir)
        os.chdir(dir)
        self.style_build()
        self.prep()
        self.indent = 0
    def end(self, c : cmd, n : node, o):
        assert self.indent == 0
        self.backmatter()
        self.index()
        for s in self.series:
            self.series_build(s)
        os.chdir('..')
    def series(self, c : cmd, n : card, o : Tuple[str, Optional[card], Optional[card]]) -> None:
        if c.datum == None:
            c.datum = True
            n.add(':html-delay', c)
            return
        trunk = o[0]
        prev  = o[1]
        next  = o[2]
        self.out('<p>')
        if prev != None:
            self.href_start(n, node_place(None, prev))
        self.text(c, n, '<')
        if prev != None:
            self.href_end()
        self.text(c, n, ' ' + trunk + ' ')
        if next != None:
            self.href_start(n, node_place(None, next))
        self.text(c, n, '>')
        if next != None:
            self.href_end()
        self.out('</p>')
        
    def prep(self): # Build all filenames and anchors.
        for c in self.deck.cards:
            file = c.get(html_file, str, c.id() + '.html')
            c.set(html_file, file)
            c.set(html_anchor, html.escape(c.get(html_anchor, str, c.id())))
            for f in c.frags:
                f.set(html_file, file)
                f.set(html_anchor, html.escape(f.get(html_anchor, str, f.id())))
        self.frontmatter()
    def href_start(self, fr : node, p : place):
        if isinstance(p, url_place):
            ref = p.url
        else:
            assert isinstance(p, span_place) or isinstance(p, node_place)
            ref = self.href(fr, p.node)
        self.out(self.html_href_pair[0].format(**{ 'ref' : ref }))
    def href_end(self):
        self.out(self.html_href_pair[1])
    def formatif(self, notempty : str, empty : str, s : str):
        return empty if s == '' else notempty.format(s)
    def frontmatter(self) -> None:
        pass
    def backmatter(self) -> None:
        pass
    def index(self) -> None:
        pass
    def series_build(self, s):
        pass
    def outnl(self, content : str):
        self.out('\n' + self.indent * 8 * ' ' + content)
    def out(self, content : str):
        self.fd.write(content)
    def style_text(self, obj):
        return '\n'.join(obj.get(html_style, list, []))
    def style_build(self):
        self.style_file = self.deck.get(html_style_file, str, 'style.css')
        with open(self.style_file, 'w') as fd:
            fd.write(self.style_text(self.deck) + '\n')
    def href(self, fr : node, to : node):
        h = '#' + to.get(html_anchor)
        if fr.get(html_file) != to.get(html_file):
            h = to.get(html_file) + h
        return h
            
engines = {
    'html' : html_eng
}

L_HERE  = 0
L_START = 1
L_END   = 2

INVALID     =  0
CARD_BEGIN  =  1
CARD_END    =  2
FRAG_BEGIN  =  3
FRAG_END    =  4
PARA_BEGIN  =  5
PARA_END    =  6
CODE_BEGIN  =  7
CODE_END    =  8
MATH_BEGIN  =  9
MATH_END    = 10
LSRC_BASE   = 11
LSRC_HERE   = LSRC_BASE + L_HERE
LSRC_START  = LSRC_BASE + L_START
LSRC_END    = LSRC_BASE + L_END
LTGT_BASE   = 15
LTGT_HERE   = LTGT_BASE + L_HERE
LTGT_START  = LTGT_BASE + L_START
LTGT_END    = LTGT_BASE + L_END
TEXT        = 18
STYLE_BEGIN = 19
STYLE_END   = 20
BEGIN       = 21
END         = 22
SERIES      = 23

opnames = {
    INVALID     : 'INVALID',
    CARD_BEGIN  : 'CARD_BEGIN',
    CARD_END    : 'CARD_END',
    FRAG_BEGIN  : 'FRAG_BEGIN',
    FRAG_END    : 'FRAG_END',
    PARA_BEGIN  : 'PARA_BEGIN',
    PARA_END    : 'PARA_END',
    CODE_BEGIN  : 'CODE_BEGIN',
    CODE_END    : 'CODE_END',
    MATH_BEGIN  : 'MATH_BEGIN',
    MATH_END    : 'MATH_END',
    LSRC_HERE   : 'LSRC_HERE',
    LSRC_START  : 'LSRC_START',
    LSRC_END    : 'LSRC_END',
    LTGT_HERE   : 'LTGT_HERE',
    LTGT_START  : 'LTGT_START',
    LTGT_END    : 'LTGT_END',
    TEXT        : 'TEXT',
    STYLE_BEGIN : 'STYLE_BEGIN',
    STYLE_END   : 'STYLE_END',
    BEGIN       : 'BEGIN',
    END         : 'END',
    SERIES      : 'SERIES'
}

S_EMPHASIS = 1
S_ITALIC   = 2
S_BOLD     = 3
S_CODE     = 4

stylenames = {
    'em' : S_EMPHASIS,
    'it' : S_ITALIC,
    'bd' : S_BOLD,
    'cd' : S_CODE
}

@typechecked
class cmd:
    def __init__(self, opc : int, obj = None, n : Optional[node] = None):
        self.opc   = opc
        self.node  = n
        self.obj   = obj
        self.datum = None
    def __str__(self):
        return opnames[self.opc] + ' node: ' + str(type(self.node)) + ' obj: ' + (self.obj if self.opc == TEXT else str(type(self.obj)))

def main():
    parser = argparse.ArgumentParser(description='Card reader.')
    parser.add_argument('-c', '--config', type=str, default='card.conf', help='Config file.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    parser.add_argument('files', nargs=argparse.REMAINDER, help='Card files to be processed.')
    args = parser.parse_args()

    rolodex = deck()
    rolodex.configread(args.config)
    for file in args.files:
        rolodex.cardread(file)
    rolodex.crossref()
    rolodex.build()
    if args.verbose:
        print(rolodex)
        
if __name__ == '__main__':
    main()

#  Local variables:
#  python-indent-offset: 4
#  End:
